From 79f8b4ba7f86a5134b1f80afd4401aa1af2bd7c2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andreas=20F=C3=A4rber?= <afaerber@suse.de>
Date: Mon, 9 Dec 2019 22:34:06 +0100
Subject: [PATCH 1/4] dt-bindings: vendor-prefixes: Add Fuda Hisi
 Microelectronics
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Assign vendor prefix "fdhisi", based on their domain name.

Cc: sales@fdhisi.com
Acked-by: Rob Herring <robh@kernel.org>
Signed-off-by: Andreas FÃ¤rber <afaerber@suse.de>
---
 Documentation/devicetree/bindings/vendor-prefixes.yaml | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 6046f4555852..4a290ddf4792 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -331,6 +331,8 @@ patternProperties:
     description: Fastrax Oy
   "^fcs,.*":
     description: Fairchild Semiconductor
+  "^fdhisi,.*":
+    description: Fuzhou Fuda Hisi Microelectronics Co., Ltd.
   "^feiyang,.*":
     description: Shenzhen Fly Young Technology Co.,LTD.
   "^firefly,.*":
-- 
2.17.1

From 30db41d740f8d8fcdd9cc085702b756db9ca2f99 Mon Sep 17 00:00:00 2001
From: Ezra Buehler <ezra@easyb.ch>
Date: Sun, 29 Mar 2020 08:45:01 +0000
Subject: [PATCH 2/4] WIP: auxdisplay: add FD6551 driver

Signed-off-by: Ezra Buehler <ezra@easyb.ch>
---
 drivers/auxdisplay/Kconfig  |   6 ++
 drivers/auxdisplay/Makefile |   1 +
 drivers/auxdisplay/fd6551.c | 184 ++++++++++++++++++++++++++++++++++++
 drivers/auxdisplay/fd6551.h |  10 ++
 4 files changed, 201 insertions(+)
 create mode 100644 drivers/auxdisplay/fd6551.c
 create mode 100644 drivers/auxdisplay/fd6551.h

diff --git a/drivers/auxdisplay/Kconfig b/drivers/auxdisplay/Kconfig
index b8313a04422d..5b6823a21a9b 100644
--- a/drivers/auxdisplay/Kconfig
+++ b/drivers/auxdisplay/Kconfig
@@ -471,6 +471,12 @@ choice
 
 endchoice
 
+config FD6551
+        tristate "FD6551 driver"
+        depends on I2C
+        help
+          Say Y to enable the FD6551 driver.
+
 endif # AUXDISPLAY
 
 config PANEL
diff --git a/drivers/auxdisplay/Makefile b/drivers/auxdisplay/Makefile
index cf54b5efb07e..8295f86cbefd 100644
--- a/drivers/auxdisplay/Makefile
+++ b/drivers/auxdisplay/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_IMG_ASCII_LCD)	+= img-ascii-lcd.o
 obj-$(CONFIG_HD44780)		+= hd44780.o
 obj-$(CONFIG_HT16K33)		+= ht16k33.o
 obj-$(CONFIG_PARPORT_PANEL)	+= panel.o
+obj-$(CONFIG_FD6551)		+= fd6551.o
diff --git a/drivers/auxdisplay/fd6551.c b/drivers/auxdisplay/fd6551.c
new file mode 100644
index 000000000000..04a7ac46693e
--- /dev/null
+++ b/drivers/auxdisplay/fd6551.c
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Ezra Buehler <spam@easyb.ch>
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+
+#include "fd6551.h"
+
+#define TEST 1
+
+struct fd6551_data {
+	struct mutex update_lock;
+	u8 i2c_addr;
+};
+
+
+#ifdef TEST
+
+static int fd6551_test(struct i2c_client *client, const char *args, size_t len)
+{
+	char *arg, *buf;
+	u8 addr, val;
+	long res;
+	int err;
+
+	buf = kmalloc(len, GFP_KERNEL);
+	strlcpy(buf, args, len);
+	arg = strsep(&buf, " ");
+	err = kstrtol(arg, 0, &res);
+	if (err)
+		goto error;
+	addr = (u8)res;
+	arg = strsep(&buf, " ");
+	if (arg == NULL) {
+		dev_err(&client->dev, "Second argument missing, aborting...");
+		err = -1;
+		goto error;
+	}
+	err = kstrtol(arg, 0, &res);
+	if (err)
+		goto error;
+	val = (u8)res;
+
+	dev_dbg(&client->dev, "Sending: 0x%02x, 0x%02x", addr, val);
+
+	return fd6551_write(client, addr, val);
+
+error:
+	kfree(buf);
+	return err;
+}
+
+static ssize_t show_test(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "Usage: echo <addr> <val> > test\n");
+}
+
+static ssize_t store_test(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	struct i2c_client *client;
+	int ret;
+	client = to_i2c_client(dev);
+
+	ret = fd6551_test(client, buf, len);
+	if (ret < 0)
+		return ret;
+
+	return len;
+}
+
+static DEVICE_ATTR(test, S_IRUGO | S_IWUSR, show_test, store_test);
+
+static struct attribute *fd6551_attrs[] = {
+	&dev_attr_test.attr,
+	NULL,
+};
+
+static const struct attribute_group fd6551_group = {
+	.name = "fd6551",
+	.attrs = fd6551_attrs,
+};
+
+#endif
+
+int fd6551_write(struct i2c_client *client, u8 addr, u8 val)
+{
+	struct fd6551_data *data = i2c_get_clientdata(client);
+	u8 buf = val;
+
+	if (mutex_lock_interruptible(&data->update_lock) < 0)
+		return -EAGAIN;
+
+	dev_dbg(&client->dev, "addr: %02x, val: %02x\n", addr, val);
+
+	client->addr = addr;
+	i2c_transfer_buffer_flags(client, &buf, 1, I2C_M_IGNORE_NAK);
+	client->addr = data->i2c_addr;
+
+	mutex_unlock(&data->update_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fd6551_write);
+
+static void fd6551_init_hw(struct i2c_client *client)
+{
+	dev_dbg(&client->dev, "Init");
+}
+
+static int fd6551_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct fd6551_data *data;
+	int err;
+
+	data = devm_kzalloc(&client->dev,
+			sizeof(struct fd6551_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	data->i2c_addr = client->addr;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+    #ifdef TEST
+	err = sysfs_create_group(&client->dev.kobj, &fd6551_group);
+	if (err < 0) {
+		dev_err(&client->dev, "couldn't register sysfs group\n");
+		goto exit;
+	}
+    #endif
+
+	fd6551_init_hw(client);
+
+	return 0;
+
+exit:
+	return err;
+}
+
+static int fd6551_remove(struct i2c_client *client)
+{
+    #ifdef TEST
+	sysfs_remove_group(&client->dev.kobj, &fd6551_group);
+    #endif
+	return 0;
+}
+
+static const struct i2c_device_id fd6551_id[] = {
+	{"fd6551", 0},
+	{}
+};
+
+static const struct of_device_id fd6551_i2c_dt_match[] = {
+	{ .compatible = "fdhisi,fd6551" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, fd6551_i2c_dt_match);
+
+static struct i2c_driver fd6551_i2c_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		   .name = "fd6551",
+		   },
+	.probe = fd6551_probe,
+	.remove = fd6551_remove,
+	.id_table = fd6551_id,
+};
+
+module_i2c_driver(fd6551_i2c_driver);
+
+MODULE_DESCRIPTION("FD6551 driver");
+MODULE_AUTHOR("Ezra Buehler <spam@easyb.ch");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/auxdisplay/fd6551.h b/drivers/auxdisplay/fd6551.h
new file mode 100644
index 000000000000..318f24187fa6
--- /dev/null
+++ b/drivers/auxdisplay/fd6551.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _FD6551_H
+#define _FD6551_H
+
+#include <linux/i2c.h>
+
+int fd6551_write(struct i2c_client *client, u8 addr, u8 val);
+
+#endif /* FD6551_H */
-- 
2.17.1

From d6ec74917705caec1a50b547c4a0740570a2c1fd Mon Sep 17 00:00:00 2001
From: Ezra Buehler <ezra@easyb.ch>
Date: Thu, 12 Mar 2020 05:51:46 +0000
Subject: [PATCH 3/4] WIP: auxdisplay: add 7-segment display driver

Signed-off-by: Ezra Buehler <ezra@easyb.ch>
---
 drivers/auxdisplay/Kconfig        |   6 +
 drivers/auxdisplay/Makefile       |   1 +
 drivers/auxdisplay/sevensegdisp.c | 393 ++++++++++++++++++++++++++++++
 3 files changed, 400 insertions(+)
 create mode 100644 drivers/auxdisplay/sevensegdisp.c

diff --git a/drivers/auxdisplay/Kconfig b/drivers/auxdisplay/Kconfig
index 5b6823a21a9b..1a2e7f340e21 100644
--- a/drivers/auxdisplay/Kconfig
+++ b/drivers/auxdisplay/Kconfig
@@ -471,6 +471,12 @@ choice
 
 endchoice
 
+config 7SEGDISPLAY
+       tristate "7-segment display driver"
+       depends on FD6551
+       help
+         Say Y to enable the 7-segment display driver.
+
 config FD6551
         tristate "FD6551 driver"
         depends on I2C
diff --git a/drivers/auxdisplay/Makefile b/drivers/auxdisplay/Makefile
index 8295f86cbefd..81a7edc9ed88 100644
--- a/drivers/auxdisplay/Makefile
+++ b/drivers/auxdisplay/Makefile
@@ -3,6 +3,7 @@
 # Makefile for the kernel auxiliary displays device drivers.
 #
 
+obj-$(CONFIG_7SEGDISPLAY)	+= sevensegdisp.o
 obj-$(CONFIG_CHARLCD)		+= charlcd.o
 obj-$(CONFIG_ARM_CHARLCD)	+= arm-charlcd.o
 obj-$(CONFIG_KS0108)		+= ks0108.o
diff --git a/drivers/auxdisplay/sevensegdisp.c b/drivers/auxdisplay/sevensegdisp.c
new file mode 100644
index 000000000000..c27e9bd6f168
--- /dev/null
+++ b/drivers/auxdisplay/sevensegdisp.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * 7-segment display driver
+ *
+ * Copyright (C) 2020 Ezra Buehler
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <uapi/linux/map_to_7segment.h>
+
+#include "fd6551.h"
+
+#define SEG7DISP_GLYPHS_SIZE 7 + 1
+#define SEG7DISP_ATTRS_SIZE SEG7DISP_GLYPHS_SIZE + 2
+
+static DEFINE_MUTEX(seg7disp_mutex);
+
+struct seg7disp_glyph {
+	const char* name;
+	u32 bit;
+	struct device_attribute devattr;
+};
+
+static struct seg7disp_data {
+	struct i2c_client *controller;
+	bool enable;
+	u8 ndigits;
+	u32 *digit_addrs;
+	u32 glyph_addr;
+	u32 enable_addr;
+	bool flipped;
+	struct seg7disp_glyph *glyphs[SEG7DISP_GLYPHS_SIZE];
+	u8 glyphs_state;
+} seg7disp_data;
+
+static SEG7_DEFAULT_MAP(map_seg7);
+
+unsigned char flip_seg7(unsigned char val)
+{
+	unsigned char new = 0;
+
+	new |= val & 1 << BIT_SEG7_A ? 1 << BIT_SEG7_D : 0;
+	new |= val & 1 << BIT_SEG7_B ? 1 << BIT_SEG7_E : 0;
+	new |= val & 1 << BIT_SEG7_C ? 1 << BIT_SEG7_F : 0;
+	new |= val & 1 << BIT_SEG7_D ? 1 << BIT_SEG7_A : 0;
+	new |= val & 1 << BIT_SEG7_E ? 1 << BIT_SEG7_B : 0;
+	new |= val & 1 << BIT_SEG7_F ? 1 << BIT_SEG7_C : 0;
+	new |= val & 1 << BIT_SEG7_G;
+
+	return new;
+}
+
+static ssize_t digits_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "tbd\n");
+}
+
+static ssize_t digits_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t len)
+{
+	int i;
+	int rc;
+	u8 val, addr;
+
+	for (i = 0; i < seg7disp_data.ndigits; i++) {
+		val = map_to_seg7(&map_seg7, buf[i]);
+		if (seg7disp_data.flipped)
+			val = flip_seg7(val);
+		addr = seg7disp_data.digit_addrs[i];
+		rc = fd6551_write(seg7disp_data.controller, addr, val);
+		if (rc < 0) {
+			pr_err("Failed to write to display controller\n");
+			return rc;
+		}
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR_RW(digits);
+
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d\n", seg7disp_data.enable);
+}
+
+static ssize_t enable_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t len)
+{
+	if (buf[0] == '1')
+		seg7disp_data.enable = true;
+	else if (buf[0] == '0')
+		seg7disp_data.enable = false;
+	else
+		return -EINVAL;
+
+	fd6551_write(seg7disp_data.controller, seg7disp_data.enable_addr,
+		     seg7disp_data.enable ? 1 : 0);
+
+	return len;
+}
+
+static DEVICE_ATTR_RW(enable);
+
+static ssize_t glyph_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%02x\n", seg7disp_data.glyphs_state);
+}
+
+static ssize_t glyph_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t len)
+{
+	int i;
+	int rc;
+	const struct seg7disp_glyph *glyph;
+	const char *name = attr->attr.name;
+	bool enable;
+
+	if (buf[0] == '1')
+		enable = true;
+	else if (buf[0] == '0')
+		enable = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < SEG7DISP_GLYPHS_SIZE - 1; i++) {
+		if (!strcmp(seg7disp_data.glyphs[i]->name, name)) {
+			glyph = seg7disp_data.glyphs[i];
+
+			if (enable)
+				seg7disp_data.glyphs_state |= 1 << glyph->bit;
+			else
+				seg7disp_data.glyphs_state &= ~(1 << glyph->bit);
+
+			rc = fd6551_write(seg7disp_data.controller,
+					  seg7disp_data.glyph_addr,
+					  seg7disp_data.glyphs_state);
+			if (rc < 0) {
+				pr_err("Failed to write to display controller\n");
+				return rc;
+			}
+			break;
+		}
+	}
+
+	return len;
+}
+
+static struct attribute *seg7disp_attrs[SEG7DISP_ATTRS_SIZE] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group seg7disp_group = {
+	.name = "seg7disp",
+	.attrs = seg7disp_attrs,
+};
+
+static int seg7disp_register_digits(struct device *dev)
+{
+	int i;
+	int ret;
+
+	ret = ENOBUFS;
+	for (i = 0; i < SEG7DISP_ATTRS_SIZE - 1; i++) {
+		if (seg7disp_attrs[i] == NULL) {
+			seg7disp_attrs[i] = &dev_attr_digits.attr;
+			seg7disp_attrs[i + 1] = NULL;
+			ret = 0;
+			break;
+		}
+	}
+
+	if (!ret)
+		ret = sysfs_update_group(&dev->kobj, &seg7disp_group);
+
+	return ret;
+}
+
+static int seg7disp_register_glyph(struct device *dev, const char *name,
+				   u32 bit)
+{
+	int i;
+	int ret;
+	struct seg7disp_glyph *glyph;
+
+	ret = -ENOBUFS;
+	for (i = 0; i < SEG7DISP_GLYPHS_SIZE - 1; i++) {
+		if (seg7disp_data.glyphs[i] == NULL) {
+			glyph = devm_kzalloc(dev, sizeof(struct seg7disp_glyph),
+					     GFP_KERNEL);
+			glyph->name = name;
+			glyph->bit = bit;
+			glyph->devattr.attr.name = name;
+			glyph->devattr.attr.mode = 0644;
+			glyph->devattr.show = &glyph_show;
+			glyph->devattr.store = &glyph_store;
+			seg7disp_data.glyphs[i] = glyph;
+			seg7disp_data.glyphs[i + 1] = NULL;
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	ret = -ENOBUFS;
+	for (i = 0; i < SEG7DISP_ATTRS_SIZE - 1; i++) {
+		if (seg7disp_attrs[i] == NULL) {
+			seg7disp_attrs[i] = &glyph->devattr.attr;
+			seg7disp_attrs[i + 1] = NULL;
+			ret = 0;
+			break;
+		}
+	}
+
+	if (!ret)
+		ret = sysfs_update_group(&dev->kobj, &seg7disp_group);
+
+	return ret;
+}
+
+static void seg7disp_init(void)
+{
+	seg7disp_data.controller = NULL;
+	seg7disp_data.enable = false;
+	seg7disp_data.ndigits = 0;
+	seg7disp_data.digit_addrs = NULL;
+	seg7disp_data.enable_addr = 0;
+	seg7disp_data.glyph_addr = 0;
+	seg7disp_data.flipped = false;
+	seg7disp_data.glyphs[0] = NULL;
+	seg7disp_data.glyphs_state = 0;
+}
+
+static int seg7disp_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int err;
+	size_t i;
+	struct device_node *node;
+	const char *names[SEG7DISP_GLYPHS_SIZE];
+	size_t nglyphs;
+
+	pr_info("hello\n");
+
+	seg7disp_init();
+
+	node = of_parse_phandle(np, "display-controller", 0);
+	if (!node) {
+		pr_err_ratelimited("Display controller property not found\n");
+		err = -EINVAL;
+		goto error;
+	}
+	seg7disp_data.controller = of_find_i2c_device_by_node(node);
+	if (!seg7disp_data.controller) {
+		err = -EPROBE_DEFER;
+		goto error;
+	}
+
+	err = sysfs_create_group(&pdev->dev.kobj, &seg7disp_group);
+	if (err < 0) {
+		dev_err(&pdev->dev, "couldn't register sysfs group\n");
+		goto error;
+	}
+
+	for_each_child_of_node(np, node) {
+		if (of_node_name_eq(node, "digits")) {
+
+			seg7disp_data.ndigits = of_property_count_elems_of_size(
+				node, "reg", sizeof(u32));
+			if (seg7disp_data.ndigits <= 0) {
+				pr_err_ratelimited("No digits configured\n");
+				continue;
+			}
+			seg7disp_data.digit_addrs = kcalloc(
+				seg7disp_data.ndigits, sizeof(u32), GFP_KERNEL);
+			if (!seg7disp_data.digit_addrs) {
+				pr_err_ratelimited(
+					"Could not allocate memory for digits\n");
+				continue;
+			}
+			err = of_property_read_u32_array(
+				node, "reg", seg7disp_data.digit_addrs,
+				seg7disp_data.ndigits);
+			if (err < 0) {
+				pr_err_ratelimited(
+					"Could not read digit addresses\n");
+				continue;
+			}
+			err = seg7disp_register_digits(&pdev->dev);
+			if (err < 0) {
+				pr_err_ratelimited(
+					"Could not register digits\n");
+				continue;
+			}
+			seg7disp_data.flipped = of_property_read_bool(
+				node, "digits-flipped");
+
+		} else if (of_node_name_eq(node, "glyphs")) {
+			err = of_property_read_u32(
+				node, "reg", &seg7disp_data.glyph_addr);
+			if (err < 0) {
+				pr_err_ratelimited(
+					"Could not read glyph reg property\n");
+				continue;
+			}
+			nglyphs = of_property_count_strings(node,
+							    "glyph-names");
+			err = of_property_read_string_array(node, "glyph-names",
+							    names, nglyphs);
+			if (err < 0) {
+				pr_err_ratelimited(
+					"Could not read glyph name\n");
+				continue;
+			}
+			for (i = 0; i < nglyphs; i++) {
+				err = seg7disp_register_glyph(&pdev->dev,
+							      names[i], i);
+				if (err < 0) {
+					pr_err_ratelimited(
+						"Could not register glyph '%s'\n",
+						names[i]);
+					continue;
+				}
+			}
+		} else if (of_node_name_eq(node, "enable")) {
+			err = of_property_read_u32(
+				node, "reg", &seg7disp_data.enable_addr);
+			if (err < 0) {
+				pr_err_ratelimited(
+					"Could not read enable reg property\n");
+				continue;
+			}
+		}
+	}
+
+	if (!seg7disp_data.enable_addr) {
+		pr_err_ratelimited("No 'enable' node found in DT\n");
+		err = -EINVAL;
+		goto free_digits;
+	}
+
+	return 0;
+
+free_digits:
+	if (seg7disp_data.digit_addrs)
+		kfree(seg7disp_data.digit_addrs);
+error:
+	return err;
+}
+
+static int seg7disp_remove(struct platform_device *pdev)
+{
+	pr_info("remove\n");
+	sysfs_remove_group(&pdev->dev.kobj, &seg7disp_group);
+	kfree(seg7disp_data.digit_addrs);
+	return 0;
+}
+
+static const struct of_device_id seg7disp_match[] = {
+	{ .compatible = "seven-segment-display" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, seg7disp_match);
+
+static struct platform_driver seg7disp_driver = {
+	.driver = {
+		.name		= "seg7disp",
+		.of_match_table = seg7disp_match,
+	},
+	.probe	= seg7disp_probe,
+	.remove = seg7disp_remove,
+};
+
+module_platform_driver(seg7disp_driver);
+
+MODULE_DESCRIPTION("7-segment display driver");
+MODULE_AUTHOR("Ezra Buehler <ezra@easyb.ch>");
+MODULE_LICENSE("GPL v2");
-- 
2.17.1

From 318a775c22ac5c1144f7003889bf858133bea2b7 Mon Sep 17 00:00:00 2001
From: Ezra Buehler <ezra@easyb.ch>
Date: Sat, 21 Mar 2020 18:46:16 +0000
Subject: [PATCH 4/4] TEST: dts: add display

---
 .../boot/dts/rockchip/rk3328-box-h96mp.dts    | 38 +++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3328-box-h96mp.dts b/arch/arm64/boot/dts/rockchip/rk3328-box-h96mp.dts
index 9a0965b577ac..72a1d0663f84 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-box-h96mp.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-box-h96mp.dts
@@ -90,6 +90,44 @@
 		};
 	};
 
+	i2c-gpio-0 {
+		compatible = "i2c-gpio";
+		gpios = <&gpio2 RK_PC6 GPIO_ACTIVE_HIGH /* sda */
+			 &gpio2 RK_PC3 GPIO_ACTIVE_HIGH /* scl */
+			>;
+		i2c-gpio,sda-open-drain;
+		i2c-gpio,scl-open-drain;
+		i2c-gpio,delay-us = <2>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		fd6551: display-controller@0 {
+			compatible = "fdhisi,fd6551";
+			reg = <0x08>;
+		};
+	};
+
+	aux-display {
+		compatible = "seven-segment-display";
+		display-controller = <&fd6551>;
+
+		enable@0x24 {
+			reg = <0x24>;
+		};
+
+		glyphs@0x33 {
+			reg = <0x33>;
+			glyph-names = "alarm", "usb", "play", "pause", "colon",
+				"ethernet", "wifi";
+		};
+
+		digits@0x34 {
+			reg = <0x34>, <0x35>, <0x36>, <0x37>;
+			digits-flipped;
+		};
+	};
+
 	sdio_pwrseq: sdio-pwrseq {
 		compatible = "mmc-pwrseq-simple";
 		pinctrl-names = "default";
-- 
2.17.1

